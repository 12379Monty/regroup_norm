<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.7">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/combine/npm/katex@0.16.25/dist/katex.min.js,npm/katex@0.16.25/dist/contrib/auto-render.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/render-katex.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<!--
### LONG_EVAL = TRUE  {-}
-->
<!-- ######################################################################## -->
<hr />
<!--

* What data?  Where the data are.  Where they are not.  Etc.

-->
<br/>
<pre><code class="language-r">params_lst &lt;- list( 
   AE_ID  = &quot;E-MEXP-1172&quot;, 
   files_loc = &quot;../extData/E-MEXP-1172&quot;, 
   platform_ID = &quot;A-AFFY-42&quot;, 
   designTable = &quot;A-AFFY-42.additional.txt&quot;)

if(F) 
data.frame( 
   feature = names(params_lst), 
   value = unlist(params_lst)) %&gt;%
knitr::kable( 
row.names = F, 
caption = &quot;Run Parameters&quot;)
</code></pre>
<h2 id="sec:run-parameters" class="unnumbered">Run Parameters</h2>
<pre><code class="language-r">   cat(sprintf( &quot;- &lt;span style = 'color:grey'&gt;%s:&lt;/span&gt; `%s`  \n&quot;, 
   names(params_lst), params_lst))  
</code></pre>
<ul>
<li><span style = 'color:grey'>AE_ID:</span> <code>E-MEXP-1172</code></li>
<li><span style = 'color:grey'>files_loc:</span> <code>../extData/E-MEXP-1172</code></li>
<li><span style = 'color:grey'>platform_ID:</span> <code>A-AFFY-42</code></li>
<li><span style = 'color:grey'>designTable:</span> <code>A-AFFY-42.additional.txt</code></li>
</ul>
<br/>
<h1 id="chp:array-design" class="tabset">Array Design</h1>
<h2 id="sec:home_1" class="unnumbered">Home</h2>
<pre><code class="language-r">AE_array_frm &lt;- with(params_lst, 
data.table::fread(file.path(&quot;../extData&quot;, platform_ID, designTable)))

AE_array_frm %&lt;&gt;% dplyr::select(-V8) %&gt;% dplyr::rename(regionName = targetName)

saveObj(paste0(&quot;_get_data_&quot;,params_lst$platform_ID, &quot;_array_frm&quot;),
&quot;AE_array_frm&quot;)
</code></pre>
<pre><code class="language-r">loadObj(
  paste0(&quot;_get_data_&quot;,params_lst$platform_ID, &quot;_array_frm&quot;), 
  &quot;AE_array_frm&quot;)
</code></pre>
<p>Define functions â€¦</p>
<pre><code class="language-r"># Define function to find the longest common substring.

# A common approach is to find the actual substring with a custom function.
# The following Stack Overflow example uses a dynamic programming approach to
# find the longest common substring.  Credit:
# https://stackoverflow.com/a/35384317/989255

# Troubleshooting
xxx  &lt;- function() { 
  JJ &lt;- 1 
  a &lt;- AE_array_plus_frm$reporterRefSeq[JJ] 
  b &lt;- AE_array_plus_frm$reporterRefSeq[JJ+1] 
}


find_lcs_str_f &lt;- function(a, b) { 
  Result &lt;- c( 
  loc = NA, 
  len = NA, 
  lcs = NA)

  if(!is.na(a) &amp; !is.na(b)) { 
    A &lt;- strsplit(a, &quot;&quot;)[[1]]         # from strib 
    B &lt;- strsplit(b, &quot;&quot;)[[1]] 
    L &lt;- matrix(0, length(A), length(B)) 
    ones &lt;- which(outer(A, B, &quot;==&quot;), arr.ind = TRUE) 
    ones &lt;- ones[order(ones[, 1]), ]
  
    for (i in 1:nrow(ones)) { 
      v &lt;- ones[i, , drop = FALSE] 
      L[v] &lt;- ifelse(any(v == 1), 1, L[v - 1] + 1) 
    }
  
    max_len &lt;- max(L) 
    if (max_len == 0) return(&quot;&quot;)
    
    max_loc &lt;- which(L == max_len, arr.ind = TRUE)[1, ] 
    max_str &lt;- paste0(A[(max_loc[1] - max_len + 1):max_loc[1]], collapse = &quot;&quot;)
  
    # Changed from  list()
    Result = c( 
    loc = max_loc[[1]] - max_len[1] + 1, len = max_len, 
    lcs = max_str) 
   } #if(!is.na(a) &amp; !is.na(b))
   return(Result) 
} #find_lcs_str_f
</code></pre>
<h2 id="sec:overview" class="unnumbered">Overview ##</h2>
<!--
<p><p/>
* Read and save table as is.
   - preserve the ordering as it will be assumed that the cel files are stored
     in the same order 
-->
<p><p/>
* The array has 2560 x 2560 = 6553600 cels or features which are described
by line items in a 6553600 x 7 table - A-AFFY-42.additional.txt: 
   - The first 4 columns describe the spots on the array:
      - **Row, Column, reporterName, reporterSequence** 
   - The last 3 columns describe the targeted sequence in yeast:
      - **regionName (yeast chrom), targetStart, targetEnd**
<!--
<p><p/>
* By inspection we see that rows of annotated yeast targets are
interleaved with rows of targets with little annotation.

annotation_num_frm <- AE_array_frm %>%
dplyr::group_by(Row)  %>%
dplyr::summarize(
  N_annot = sum(!is.na(regionName))
)
-->
<ul>
<li>Of the 6553600 cells.
<ul>
<li>2753719 interrogate the yeast genome</li>
<li>This is a bit less than what claude.ai Sonnet 4.5 found  -
See Section <a href="#gene-annot">@gene-annot</a>.</li>
</ul>
</li>
</ul>
<br/>
<h2 id="sec:content-design-highlights" class="unnumbered">Content Design Highlights</h2>
<p><p/>
* See <span style="font-variant:small-caps;">methods</span> section
in Lee et al. (2007) [@Lee:2007aa].
<p><p/>
* Interrogates the **<span style = 'color:blue'>entire genomic  sequence</span>**,
including repetitive elements. 
   - the repetitive elements provide no useful.
   - genomic location has been  set  so missing for these
<p><p/>
* Includes oligonucleotides to interrogate the 
<span style = 'color:blue'>**forward** and **reverse** strands</span>.^[
forward/reverse, plus/minus, sense/antisense are used interchangeably her
here.
<ul>
<li><strong><span style = 'color:blue'>25mer probes</span></strong> were tiled
at <strong><span style = 'color:blue'>8bp intervals</span></strong> on each strand^[
measured from the central position of each oligo] creating a
sense specific overlap of 17bp.</li>
</ul>
<p><p/>
* The oligos detecting **<span style = 'color:blue'>sense and 
antisense targets were offset by 4bp</span>** to yield Â a high resolution view
of the genome
   - For a fixed region, the  capture  of targets from the complimentary strands
     involves the same diploid/double stranded sequence, but the sequence bound to
the array differs.
<!--
      - when we combine counts across the two strand specific capture modes and
compare across samples, we will see strand effects in many cases.
-->
<!-- May be incorrect - see _get_data_truncated_pobes.md
<p><p/>
* **approximately <span style = 'color:blue'>2% of total probes were 
truncated</span>** to economize on the required number of oligonucleotide
synthesis steps.
   - this is not reflected in the probe information that we have.
-->
<br/>
<h2 id="sec:design-verification" - class="tabset">Design Verification</h2>
<h3 id="sec:home_2" class="unnumbered">Home</h3>
<br/>
<h3 id="sec:preparation" class="unnumbered">Preparation</h3>
<p><p/>
* Order targets by Reference Position, compute inter-target offset:
should be 4 bp shifts between alternating sense strands
   - **Reference Position** for probes is the **Start Position** on the sense
     strand, and the **End Position** on the anti-sense strand.
      - **sense or plus strand probes** are depicted on the
sense strand coordinate axis in the obvious way -
line up the start of the probe to the axis coordinate.
      - for the **anti-sense probes**, the anti-sense or minus strand coordinates are put
        down in the reverse direction - the last anti-sense strand coordinate
aligns with the first sense strand coordinate, and the first anti-sense strand
coordinate aligns with the last sense strand coordinate.
      - **a reference position occurs every 4bp on alternating strands**.
when the start position of sense strand probes are at 8 bp intervals,
and the end position of anti-sense strand probes are at 8 bp intervals
shifted 4bp from the sense strand probe position, 
<!--
      - an alternative design would be to lay the anti-sense probes at the same
        loci as the sense strand probes; 0 bp shift.
	 - **under what assumptions is each design preferable.?**
	    - only if strand effects are of interest 
-->
<!--
* Verify matching sequence in anti sense probes
-->
<p><p/>
* With the targets ordered by reference position within region, the target layout
can be compared to the design by examining the following quantities:
<p><p/>
   - **diffPos = refPos - lag(refPos)** : should be 4 by design
<p><p/>
   - **loc, len** = the starting position and length of the longest sequence in the
     current reporter sequence also found in previous reporter sequence
       - should be 5 and 21, respectively, by design.
<p><p/>
   - **strand2** = lag_strand || strand
<p><p/> 
* Let the triplet **Sign = (diffPos, loc, len)** denote a target's signature or
phenotype.  Signatures of interest include:
   - **(4, 5, 21)** - the Design signature
   - **(0, 1, 25)** -  Replicate target signatuge (exact same sequence)
<p><p/> 
* Other interesting target sequences are indicated by runs strand2 == mm or pp, 
indicating that only one strand is interrogated for a stretch of the genome.
<br/>
<pre><code class="language-r">AE_array_plus_frm &lt;- AE_array_frm %&gt;% 
dplyr::mutate(
sense = sign(targetEnd - targetStart), 
targetPos = ifelse(sense == 1, targetStart, targetEnd), 
rcSeq = toupper(spgs::reverseComplement(reporterSequence)), 
reporterRefSeq = ifelse(sense == 1, reporterSequence, rcSeq),
                
probeSize = nchar(reporterRefSeq), 
targetLength = abs(targetEnd - targetStart) + 1
) %&gt;% 
dplyr::arrange(regionName, targetPos) %&gt;%
dplyr::filter(!is.na(regionName))

  ### DONT SAVE AS NAME COLLIDES WITH ENHANCED VERSION
</code></pre>
<pre><code class="language-r">AE_array_plus_tibl &lt;- AE_array_plus_frm %&gt;% 
dplyr::select(-c(probeSize, targetLength, reporterSequence, rcSeq)) %&gt;% 
dplyr::group_by(regionName) %&gt;%
dplyr::arrange(regionName, targetPos) %&gt;% 
dplyr::mutate(
  sense2 = sense * dplyr::lag(sense), 
  strand = ifelse(sense == 1, 'p', 'm'),
  lag_strand = ifelse(dplyr::lag(sense) == 1, 'p', 'm'),
  diffPos = targetPos - dplyr::lag(targetPos), 
  ###regionNum = rank(targetPos),  - NOT NEEDED 
  lcs_result = purrr::map2(
    dplyr::lag(reporterRefSeq),
    reporterRefSeq, 
    find_lcs_str_f)) %&gt;% 
#tidyr::unnest(lcs_result) %&gt;%
tidyr::unnest_wider(lcs_result) %&gt;% dplyr::ungroup()%&gt;%
dplyr::arrange(regionName, targetPos, sense)

AE_array_plus_tibl %&lt;&gt;%
tidyr::unite(
 col = &quot;strand2&quot;,
 lag_strand, strand,
 sep = '')

AE_array_plus_tibl %&lt;&gt;% 
dplyr::relocate(regionName, targetPos,
                diffPos, loc, len, strand2, reporterRefSeq, 
                Row, Column, reporterName)

saveObj(&quot;_get_data_AE_array_plus_tibl&quot;, 'AE_array_plus_tibl')
</code></pre>
<pre><code class="language-r">loadObj(&quot;_get_data_AE_array_plus_tibl&quot;, 'AE_array_plus_tibl') 
</code></pre>
<pre><code class="language-r">row_lst &lt;- split(rownames(AE_array_plus_tibl),AE_array_plus_tibl$regionName)

AE_array_plus_n100_frm &lt;- do.call(&quot;rbind&quot;, lapply(row_lst, function(ROWS)
AE_array_plus_tibl[ROWS[1:100], ]))
</code></pre>
<br/>
<h3 id="sec:sample-probe-data" class="unnumbered">Sample Probe Data</h3>
<pre><code class="language-r">AE_array_plus_n100_frm %&gt;% DT::datatable(
  extensions = 'Buttons', 
  options = list(pageLength=50), 
  caption = &quot;Detailed Probe Description - First 100 by Group&quot;, 
  rownames=F)
</code></pre>
<pre><code>## PhantomJS not found. You can install it with webshot::install_phantomjs(). If it is installed, please make sure the phantomjs executable can be found via the PATH variable.
</code></pre>
<pre><code>## Error in path.expand(path): invalid 'path' argument
</code></pre>
<br/>
<h3 id="sec:probe-data-summaries" - class="tabset">Probe Data Summaries</h3>
<h4 id="sec:home_3" class="unnumbered">Home</h4>
<br/>
<h4 id="sec:top-signatures" class="unnumbered">Top Signatures</h4>
<ul>
<li>Let the quartet (diffPos, loc, len, strand2) denote a targetâ€™s signature or
phenotype.</li>
</ul>
<p><p/> 
* In the following table we see:
   - the majority of the probes (86.4%) follow the design:  a probe every 4bp
from alternating strands - 4-5-21~{mp|pm}
   - the next most prominent probe type (4.8%) occurs when the off-strand probe at
4bp offset is missing - 8-9-17~{pp|mm}
   - the next most prominent probe type are replicates from the same strand,
0-1-25~{pp|mm}.  Replicates from the off-strand are slightly less prominent -
these have signature 0-1-25~{pm|mp}.
   -  Other prominent signatures seen in Table \@(tab:get-data-probe-sum)
are pseudo replicates at offsets of 1, 2, and 3 bp. 
<pre><code class="language-r">AE_array_plus_tibl %&lt;&gt;%
tidyr::unite(
 col = &quot;probe_sign&quot;,
 diffPos, loc, len, strand2,
 sep = '~') %&gt;%
dplyr::mutate(
  probe_sign = sub(&quot;~&quot;, '-', sub(&quot;~&quot;, '-', probe_sign))
 )

probe_sign_count_frm &lt;- AE_array_plus_tibl %&gt;%
dplyr::group_by(probe_sign) %&gt;%
dplyr::summarize(
  count = dplyr::n()) %&gt;%
dplyr::mutate(
  pct = round(count / sum(count) * 100, 1)
) %&gt;%
as.data.frame()

probe_sign_count_frm %&gt;% 
dplyr::arrange(desc(count)) %&gt;%
dplyr::filter(pct &gt;= 0.1) %&gt;%
knitr::kable(
  caption = &quot;Top Tiling Array Probe Signatures&quot;
) %&gt;%
kableExtra::kable_styling(full_width = F)
</code></pre>
<table class="table" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>Top Tiling Array Probe Signatures</caption>
 <thead>
  <tr>
   <th style="text-align:left;"> probe_sign </th>
   <th style="text-align:right;"> count </th>
   <th style="text-align:right;"> pct </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> 4-5-21~mp </td>
   <td style="text-align:right;"> 1189237 </td>
   <td style="text-align:right;"> 43.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 4-5-21~pm </td>
   <td style="text-align:right;"> 1188444 </td>
   <td style="text-align:right;"> 43.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 8-9-17~pp </td>
   <td style="text-align:right;"> 66352 </td>
   <td style="text-align:right;"> 2.4 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 8-9-17~mm </td>
   <td style="text-align:right;"> 66238 </td>
   <td style="text-align:right;"> 2.4 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 0-1-25~mm </td>
   <td style="text-align:right;"> 35509 </td>
   <td style="text-align:right;"> 1.3 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 0-1-25~pp </td>
   <td style="text-align:right;"> 35153 </td>
   <td style="text-align:right;"> 1.3 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 1-2-24~mp </td>
   <td style="text-align:right;"> 12955 </td>
   <td style="text-align:right;"> 0.5 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 1-2-24~pp </td>
   <td style="text-align:right;"> 12874 </td>
   <td style="text-align:right;"> 0.5 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 1-2-24~mm </td>
   <td style="text-align:right;"> 12839 </td>
   <td style="text-align:right;"> 0.5 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 1-2-24~pm </td>
   <td style="text-align:right;"> 12778 </td>
   <td style="text-align:right;"> 0.5 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 12-13-13~pm </td>
   <td style="text-align:right;"> 12229 </td>
   <td style="text-align:right;"> 0.4 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 12-13-13~mp </td>
   <td style="text-align:right;"> 11593 </td>
   <td style="text-align:right;"> 0.4 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 0-1-25~pm </td>
   <td style="text-align:right;"> 11057 </td>
   <td style="text-align:right;"> 0.4 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 0-1-25~mp </td>
   <td style="text-align:right;"> 10742 </td>
   <td style="text-align:right;"> 0.4 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 2-3-23~mp </td>
   <td style="text-align:right;"> 6930 </td>
   <td style="text-align:right;"> 0.3 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 2-3-23~pm </td>
   <td style="text-align:right;"> 6858 </td>
   <td style="text-align:right;"> 0.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 2-3-23~mm </td>
   <td style="text-align:right;"> 5997 </td>
   <td style="text-align:right;"> 0.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 2-3-23~pp </td>
   <td style="text-align:right;"> 5971 </td>
   <td style="text-align:right;"> 0.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 3-4-22~mp </td>
   <td style="text-align:right;"> 5841 </td>
   <td style="text-align:right;"> 0.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 3-4-22~pm </td>
   <td style="text-align:right;"> 5768 </td>
   <td style="text-align:right;"> 0.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 3-4-22~pp </td>
   <td style="text-align:right;"> 5184 </td>
   <td style="text-align:right;"> 0.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 3-4-22~mm </td>
   <td style="text-align:right;"> 5061 </td>
   <td style="text-align:right;"> 0.2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 16-17-9~mm </td>
   <td style="text-align:right;"> 2684 </td>
   <td style="text-align:right;"> 0.1 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 16-17-9~pp </td>
   <td style="text-align:right;"> 2668 </td>
   <td style="text-align:right;"> 0.1 </td>
  </tr>
</tbody>
</table>
<br/>
<h4 id="sec:replicates" - class="tabset">Replicates</h4>
<h5 id="sec:home_4" class="unnumbered">Home</h5>
<br/>
<h5 id="sec:intro" class="unnumbered">Intro</h5>
<ul>
<li>
<p>We have cis-strand (pp, mm) and trans-strand (pm, mp)
replication</p>
</li>
<li>
<p>We each replicated sequence, how many replicates are there?</p>
</li>
<li>
<p>Collect set of replicated probes \(\equiv\)
all probes with reporterRefSeq in the index set (i.e. in 0-1-25~{xx}</p>
</li>
<li>
<p>Count strand specific reporterRefSeq multiplicity.</p>
</li>
</ul>
<p><p/>
* How can these be used to evaluate algorithms proposed for the
analysis of tiling array data?
   - while the replicated probes will provide accurate estimates of
some elements of variability, we need to keep in mind that these
elements constitute only a fraction of the total variability,
<!-- by region -->
<br/>
</div>
</body>
</html>
